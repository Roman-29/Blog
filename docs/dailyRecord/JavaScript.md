# JavaScript 高级程序设计（第四版）读书笔记

## 什么是JavaScript

JavaScript的实现包括以下3个部分：

### 核心（ECMAScript）

在基本的层面，它描述这门语言的如下部分：
- 语法
- 类型
- 语句
- 关键字
- 保留字
- 操作符
- 全局对象

### 文档对象模型（DOM）

**文档对象模型**（DOM，Document Object Model）是一个应用编程接口（API），用于在HTML中使用扩展的XML。

DOM通过创建表示文档的树，让开发者可以随心所欲地控制网页的内容和结构。使用DOM API，可以轻松地删除、添加、替换、修改节点。

### 浏览器对象模型（BOM）

BOM主要针对浏览器窗口和子窗口（frame），不过人们通常会把任何特定于浏览器的扩展都归在BOM的范畴内。比如，下面就是这样一些扩展：

- 弹出新浏览器窗口的能力；
- 移动、缩放和关闭浏览器窗口的能力；
- `navigator`对象，提供关于浏览器的详尽信息；
- `location`对象，提供浏览器加载页面的详尽信息；
- `screen`对象，提供关于用户屏幕分辨率的详尽信息；
- `performance`对象，提供浏览器内存占用、导航行为和时间统计的详尽信息；
- 对cookie的支持；
- 其他自定义对象，如`XMLHttpRequest`和IE的`ActiveXObject`。



## 语言基础

### 变量

#### var与let

`let`跟`var`的作用差不多，但有着非常重要的区别。最明显的区别是，`let`声明的范围是块作用域，而`var`声明的范围是函数作用域。

1. **暂时性死区**

   `let`与`var`的另一个重要的区别，就是`let`声明的变量不会在作用域中被提升。

   ```
   // name会被提升
   console.log(name); // undefined
   var name = 'Matt';
   
   // age不会被提升
   console.log(age); // ReferenceError：age没有定义
   let age = 26;
   ```

   在解析代码时，JavaScript引擎也会注意出现在块后面的`let`声明，只不过在此之前不能以任何方式来引用未声明的变量。在`let`声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此阶段引用任何后面才声明的变量都会抛出`ReferenceError`。
   
2. **全局声明**

   与`var`关键字不同，使用`let`在全局作用域中声明的变量不会成为`window`对象的属性（`var`声明的变量则会）。

   ```
   var name = 'Matt';
   console.log(window.name); // 'Matt'
   
   let age = 26;
   console.log(window.age);  // undefined
   ```

   不过，`let`声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此，为了避免`SyntaxError`，必须确保页面不会重复声明同一个变量。
   
3. **条件声明**

   在使用`var`声明变量时，由于声明会被提升，JavaScript引擎会自动将多余的声明在作用域顶部合并为一个声明。因为`let`的作用域是块，所以不可能检查前面是否已经使用`let`声明过同名变量，同时也就不可能在没有声明的情况下声明它。

   ```
   <script>
     var name = 'Nicholas';
     let age = 26;
   </script>
   
   <script>
     // 假设脚本不确定页面中是否已经声明了同名变量
     // 那它可以假设还没有声明过
   
     var name = 'Matt';
     // 这里没问题，因为可以被作为一个提升声明来处理
     // 不需要检查之前是否声明过同名变量
   
     let age = 36;
     // 如果age之前声明过，这里会报错
   </script>
   ```

   使用`try`/`catch`语句或`typeof`操作符也不能解决，因为条件块中`let`声明的作用域仅限于该块。

   ```
   <script>
     let name = 'Nicholas';
     let age = 36;
   </script>
   
   <script>
     // 假设脚本不确定页面中是否已经声明了同名变量
     // 那它可以假设还没有声明过
   
     if (typeof name === 'undefined') {
       let name;
     }
     // name被限制在if {} 块的作用域内
     // 因此这个赋值形同全局赋值
     name = 'Matt';
   
     try {
       console.log(age) // 如果age没有声明过，则会报错
     }
     catch(error) {
       let age;
     }
     // age被限制在catch {}块的作用域内
     // 因此这个赋值形同全局赋值
     age = 26;
   </script>
   ```

   为此，对于`let`这个新的ES6声明关键字，不能依赖条件声明模式。

   > **注意**　不能使用`let`进行条件式声明是件好事，因为条件声明是一种反模式，它让程序变得更难理解。如果你发现自己在使用这个模式，那一定有更好的替代方式。

4. **for循环中的let声明**

   在`let`出现之前，`for`循环定义的迭代变量会渗透到循环体外部：

   ```
   for (var i = 0; i < 5; ++i) {
     // 循环逻辑
   }
   console.log(i); // 5
   ```

   改成使用`let`之后，这个问题就消失了，因为迭代变量的作用域仅限于`for`循环块内部：

   ```
   for (let i = 0; i < 5; ++i) {
     // 循环逻辑
   }
   console.log(i); // ReferenceError: i没有定义
   ```

   在使用`var`的时候，最常见的问题就是对迭代变量的奇特声明和修改：

   ```
   for (var i = 0; i < 5; ++i) {
       setTimeout(() => console.log(i), 0)
   }
   // 你可能以为会输出0、1、2、3、4
   // 实际上会输出5、5、5、5、5
   ```

   之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的`i`都是同一个变量，因而输出的都是同一个最终值。

   而在使用`let`声明迭代变量时，JavaScript引擎在后台会为每个迭代循环声明一个新的迭代变量。每个`setTimeout`引用的都是不同的变量实例，所以`console.log`输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。

   ```
   for (let i = 0; i < 5; ++i) {
       setTimeout(() => console.log(i), 0)
   }
   // 会输出0、1、2、3、4
   ```

   这种每次迭代声明一个独立变量实例的行为适用于所有风格的`for`循环，包括`for-in`和`for-of`循环。

### 数据类型

ECMAScript有 6种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、 String 和 Symbol。Symbol（符号）是 ECMAScript 6新增的。还有一种复杂数据类型叫 Object（对象）。Object 是一种无序名值对的集合。

#### typeof 操作符 
因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。`typeof`操作符就是为此而生的。对一个值使用`typeof`操作符会返回下列字符串之一：

- `"undefined"`表示值未定义；
- `"boolean"`表示值为布尔值；
- `"string"`表示值为字符串；
- `"number"`表示值为数值；
- `"object"`表示值为对象（而不是函数）或`null`；
- `"function"`表示值为函数；
- `"symbol"`表示值为符号。

#### `Undefined`类型

`Undefined`类型只有一个值，就是特殊值`undefined`。当使用`var`或`let`声明了变量但没有初始化时，就相当于给变量赋予了`undefined`值

#### `Null`类型

`Null`类型同样只有一个值，即特殊值`null`。逻辑上讲，`null`值表示一个空对象指针，这也是给`typeof`传一个`null`会返回`"object"`的原因

#### `Boolean`类型

`Boolean`（布尔值）类型是ECMAScript中使用最频繁的类型之一，有两个字面值：`true`和`false`。这两个布尔值不同于数值，因此`true`不等于1，`false`不等于0。

#### `Number`类型

ECMAScript中最有意思的数据类型或许就是 Number 了。Number 类型使用 IEEE 754格式表示整 数和浮点值（在某些语言中也叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式。

#### `String`类型

String（字符串）数据类型表示零或多个 16 位 Unicode 字符序列。

#### `Symbol` 类型

Symbol（符号）是 ECMAScript 6新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。 符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。

#### `Object` 类型

ECMAScript中的对象其实就是一组数据和功能的集合。对象通过 new 操作符后跟对象类型的名称 来创建。开发者可以通过创建 Object 类型的实例来创建自己的对象，然后再给对象添加属性和方法

## 变量、作用域与内存

### 原始值与引用值

ECMAScript 变量可以包含两种不同类型的数据：原始值和引用值。原始值（primitive value）就是 最简单的数据，引用值（reference value）则是由多个值构成的对象。 

在把一个值赋给变量时，JavaScript 引擎必须确定这个值是原始值还是引用值。上一章讨论了 6 种原始值：Undefined、Null、Boolean、Number、String 和 Symbol。保存原始值的变量是按值（by value）访问的，因为我们操作的就是存储在变量中的实际值。

### 执行上下文与作用域

执行上下文（以下简称“上下文”）的概念在 JavaScript中是颇为重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variable object）， 而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。

每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。 在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript 程序的执行流就是通过这个上下文栈进行控制的。 

上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域 链的最前端。如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有 一个定义变量：arguments。（全局上下文中没有这个变量。）作用域链中的下一个变量对象来自包含上 下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。

### 垃圾回收

JavaScript 是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。在 C和 C++等 语言中，跟踪内存使用对开发者来说是个很大的负担，也是很多问题的来源。JavaScript 为开发者卸下 了这个负担，通过自动内存管理实现内存分配和闲置资源回收。基本思路很简单：确定哪个变量不会再 使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的。

#### 标记清理

JavaScript 最常用的垃圾回收策略是标记清理（mark-and-sweep）。当变量进入上下文，比如在函数 内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永 远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。

垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它 会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记 的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。

#### 性能

垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的 时间调度很重要。尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。 开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代码时就要做到：无论什么时候开始 收集垃圾，都能让它尽快结束工作。 

现代垃圾回收程序会基于对 JavaScript 运行时环境的探测来决定何时运行。探测机制因引擎而异，但基本上都是根据已分配对象的大小和数量来判断的。比如，根据 V8团队 2016年的一篇博文的说法： “在一次完整的垃圾回收之后，V8的堆增长策略会根据活跃对象的数量外加一些余量来确定何时再次垃圾回收。”


